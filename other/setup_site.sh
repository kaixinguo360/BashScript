#!/bin/bash
export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# 检查是否为Root
[ $(id -u) != "0" ] && { echo "Error: You must be root to run this script"; exit 1; }

# 检查系统信息
if [ ! -z "`cat /etc/issue | grep 'Ubuntu 16'`" ];
    then
        OS='Ubuntu'
    else
        echo "Not support OS(Ubuntu 16), Please reinstall OS and retry!"
        #exit 1
fi


# 正式安装开始

# 设置变量
NGINX_CONF='/etc/nginx/sites-enabled/'
MY_CONF='/etc/nginx/my/'
SSL_PATH='/etc/nginx/ssl/'

# 读取参数
if [[ $1 = "-h" || $1 = "--help" ]];then
  echo -e "用法: $0 [-n|--name Name] [-k|--key Key Path] [-c|--crt Crt Path]"
  echo -e "\t-n --name 主机名称"
  echo -e "\t-k --key 私钥路径"
  echo -e "\t-c --crt 公钥路径"
  exit 0
fi

if [ $1 = "" ];then

# 交互式读取输入参数
read -p '新网站的本地配置文件名: ' SITE_NAME
SITE_ROOT="/var/www/${SITE_NAME}"
while true :
do
	read -r -p "使用默认根目录(${SITE_ROOT})? [Y/n] " input
	case $input in
	    [yY][eE][sS]|[yY])
			break
            		;;

	    [nN][oO]|[nN])
			read -p '设置新的根目录: ' SITE_ROOT
			echo -e "已设置新的根目录(${SITE_ROOT})"
            		break
            		;;

	    *)
		echo "Invalid input..."
		;;
	esac
done
read -p '新网站的域名: ' SERVER_NAME
while true :
do
	read -r -p "启用SSL类型(acme.sh/自签名/不使用)? [Y/s/n] " input

	case $input in
	    [yY][eE][sS]|[yY])
	    		SSL_TYPE='y'
			break
            		;;
			

	    [sS][eE][lL][fF]|[sS])
	    		SSL_TYPE='s'
			break
            		;;

	    [nN][oO]|[nN])
	    		SSL_TYPE='n'
            		break
            		;;

	    *)
		echo "Invalid input..."
		;;
	esac
done

else

# 读取命令行输入参数
TEMP=`getopt \
    -o n:c:r:s: \
    --long host-name:,config-file:,root-path:,ssl-type, \
    -n "$0" -- "$@"`
if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
eval set -- "$TEMP"

while true ; do
    case "$1" in
        -n|--host-name)
            SERVER_NAME=$2
            shift 2
            ;;
        -c|--config-file)
            SITE_NAME=$2
            shift 2
            ;;
        -r|--root-path)
            SITE_ROOT=$(readlink -f $2)
            shift 2
            ;;
        -s|--ssl-type)
            case $2 in
                acme)
                    SSL_TYPE='y'
                    echo "使用acme.sh创建SSL"
                    ;;
                myca)
                    SSL_TYPE='s'
                    echo "使用myca.sh创建SSL"
                    ;;
                *)
                    echo "未知的SSL类型'$2'"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Internal error!"
            exit 1
            ;;
    esac
done

if [ -z "$SSL_TYPE" ];then
    SSL_TYPE='n'
    echo "不使用SSL"
fi

if [ -z "$SERVER_NAME" ];then
    echo "未设置服务器域名"
    exit 1
fi

if [ -z "$SITE_NAME" ];then
    echo "未设置配置文件名"
    exit 1
fi

if [ -z "$SITE_ROOT" ];then
    SITE_ROOT="/var/www/${SITE_NAME}"
    echo "未设置根目录,使用默认根目录(${SITE_ROOT})"
fi

for arg do
   echo "非法参数'$arg'" ;
   exit 1
done

fi

# 新建配置文件
cat > ${NGINX_CONF}${SITE_NAME} << HERE
server {
	listen 80;
	listen [::]:80;

	# SSL configuration
	#
	#listen 443 ssl;
	#listen [::]:443 ssl;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	include my/${SITE_NAME}/*.conf;

	root ${SITE_ROOT};

	# Add index.php to the list if you are using PHP
	index index.php index.html index.htm index.nginx-debian.html;

	server_name ${SERVER_NAME};

	client_max_body_size 20m;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		#try_files \$uri \$uri/ =404;
        try_files \$uri \$uri/ /index.php\$is_args\$args;
	}

	# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
	#
	location ~ \.php\$ {
		include snippets/fastcgi-php.conf;
	
		# With php7.0-cgi alone:
		#fastcgi_pass 127.0.0.1:9000;
		# With php7.0-fpm:
		fastcgi_pass unix:/run/php/php7.0-fpm.sock;
	}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	location ~ /\.ht {
		deny all;
	}
	
	# for wordpress
	location = /favicon.ico { log_not_found off; access_log off; }
	location = /robots.txt { log_not_found off; access_log off; allow all; }
	location ~* \.(css|gif|ico|jpeg|jpg|js|png)\$ {
		expires max;
		log_not_found off;
	}
}

include my/${SITE_NAME}/*.ser;

HERE

# 新建MY配置文件夹
mkdir -p ${MY_CONF}${SITE_NAME}

# 新建网站根文件夹
mkdir -p ${SITE_ROOT}

# 重启Server
service nginx restart



#############
## 开启SSL ##
#############


## 使用acme.sh证书 ##

if [ "${SSL_TYPE}" = "y" ]; then

#安装 acme.sh 以自动获取SSL证书
ACME="${HOME}/.acme.sh/acme.sh"
if [ ! -x ${ACME} ]; then
    su - $SUDO_USER -c "curl  https://get.acme.sh | sh" && source "${HOME}/.acme.sh/acme.sh.env"
fi

# 获取SSL证书
${ACME} --issue  -d  ${SERVER_NAME}  --nginx

# 安装SSL证书
mkdir -p ${SSL_PATH}
${ACME}  --installcert  -d  ${SERVER_NAME} \
        --key-file  ${SSL_PATH}${SERVER_NAME}.key \
        --fullchain-file  ${SSL_PATH}${SERVER_NAME}.crt \
        --reloadcmd  "service nginx force-reload" || exit -1

# 配置Nginx
cat > ${MY_CONF}${SITE_NAME}/ssl.conf << HERE
listen 443 ssl;
listen [::]:443 ssl;
ssl_certificate ${SSL_PATH}${SERVER_NAME}.crt;
ssl_certificate_key ${SSL_PATH}${SERVER_NAME}.key;
keepalive_timeout   70;
HERE

# 重启Server
service nginx restart
fi


## 使用自签名证书 ##

if [ "${SSL_TYPE}" = "s" ]; then

echo -e "自签名证书功能暂不稳定!!!"

#安装 myca.sh 以自动获取SSL证书
MYCA="${HOME}/.ca/myca.sh"
Password=$1
if [ "$Password" = "" ];then
	Password="12345"
fi
if [ ! -x ${MYCA} ]; then
    wget -O install.sh https://raw.githubusercontent.com/kaixinguo360/MyCA/master/install.sh \
                && chmod +x install.sh \
		&& sudo ./install.sh ${Password}
fi

# 获取SSL证书
${MYCA} issue -n ${SERVER_NAME}

# 安装SSL证书
mkdir -p ${SSL_PATH}
${MYCA} deploy --name  ${SERVER_NAME} \
        --key  ${SSL_PATH}${SERVER_NAME}.key \
        --crt  ${SSL_PATH}${SERVER_NAME}.crt || exit -1

# 配置Nginx
cat > ${MY_CONF}${SITE_NAME}/ssl.conf << HERE
listen 443 ssl;
listen [::]:443 ssl;
ssl_certificate ${SSL_PATH}${SERVER_NAME}.crt;
ssl_certificate_key ${SSL_PATH}${SERVER_NAME}.key;
keepalive_timeout   70;
HERE

# 重启Server
service nginx restart
fi

