#!/bin/bash
export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# 检查是否为Root
[ $(id -u) != "0" ] && { echo "Error: You must be root to run this script"; exit 1; }

# 检查系统信息
if [ ! -z "`cat /etc/issue | grep 'Ubuntu 16'`" ];
    then
        OS='Ubuntu'
    else
        echo "Not support OS(Ubuntu 16), Please reinstall OS and retry!"
        #exit 1
fi


# 正式安装开始

# 设置变量
NGINX_CONF='/etc/nginx/sites-enabled/'
MY_CONF='/etc/nginx/my/'
SSL_PATH='/etc/nginx/ssl/'
DEFAULT_CLIENT_CERT="${HOME}/.ca/cacert.pem"

# 读取参数
if [[ $1 = "-h" || $1 = "--help" ]];then
    echo -e "用法: $0"
    echo -e "  不加任何参数进入交互式创建模式"
    echo -e "用法: $0 [选项]"
    echo -e "  必须:"
    echo -e "    -n --host-name     主机名称"
    echo -e "    -c --config-file   配置文件名"
    echo -e "  可选:"
    echo -e "    -r --root-path     根目录, 缺省为/var/www/配置文件名"
    echo -e "    -s --ssl-type      SSL类型, 缺省为不使用SSL"
    echo -e "                       可选SSL类型:"
    echo -e "                         y|a|acme     使用acme.sh创建SSL"
    echo -e "                         s|m|myca     使用myca.sh创建自签名SSL"
    echo -e "                         n|null|none  不使用SSL"
    echo -e "    --ssl-client-cert  客户端证书路径, 为"."则使用默认路径${DEFAULT_CLIENT_CERT}"
    echo -e "    --no-restart         不重启Nginx服务器"
    exit 0
fi

# 判断输入方式
if [ -z "$1" ];then

# 交互式读取输入参数
read -p '新网站的本地配置文件名: ' SITE_NAME
SITE_ROOT="/var/www/${SITE_NAME}"
while true :
do
	read -r -p "使用默认根目录(${SITE_ROOT})? [Y/n] " input
	case $input in
	    [yY][eE][sS]|[yY])
			break
            		;;

	    [nN][oO]|[nN])
			read -p '设置新的根目录: ' SITE_ROOT
			echo -e "已设置新的根目录(${SITE_ROOT})"
            		break
            		;;

	    *)
		echo "Invalid input..."
		;;
	esac
done
read -p '新网站的域名: ' SERVER_NAME
while true :
do
	read -r -p "启用SSL类型(acme.sh/自签名/不使用)? [Y/s/n] " input

	case $input in
	    [yY][eE][sS]|[yY])
	    		SSL_TYPE='y'
			break
            		;;
			

	    [sS][eE][lL][fF]|[sS])
	    		SSL_TYPE='s'
			break
            		;;

	    [nN][oO]|[nN])
	    		SSL_TYPE='n'
            		break
            		;;

	    *)
		echo "Invalid input..."
		;;
	esac
done

else

# 命令行读取输入参数
TEMP=`getopt \
    -o n:c:r:s: \
    --long host-name:,config-file:,root-path:,ssl-type:,ssl-client-cert:,no-restart, \
    -n "$0" -- "$@"`
if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
eval set -- "$TEMP"

while true ; do
    case "$1" in
        -n|--host-name)
            SERVER_NAME=$2
            shift 2
            ;;
        -c|--config-file)
            SITE_NAME=$2
            shift 2
            ;;
        -r|--root-path)
            SITE_ROOT=$(readlink -f $2)
            shift 2
            ;;
        -s|--ssl-type)
            case $2 in
                y|a|acme)
                    SSL_TYPE='y'
                    ;;
                s|m|myca)
                    SSL_TYPE='s'
                    ;;
                n|null|none)
                    SSL_TYPE='n'
                    ;;
                *)
                    echo "未知的SSL类型'$2'"
                    exit 1
                    ;;
            esac
            shift 2
            ;;
        --ssl-client-cert)
            if [ "$2" = "." ];then
                CLIENT_CERT=${DEFAULT_CLIENT_CERT}
            else
                CLIENT_CERT=$2
            fi
            CLIENT_CERT=$(readlink -f ${CLIENT_CERT})
            shift 2
            ;;
        --no-restart)
            NO_RESTART='y'
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Internal error!"
            exit 1
            ;;
    esac
done

for arg do
   echo "非法参数'$arg'" ;
   exit 1
done

fi
# 输入参数读取完成

# 检查输入参数合法性
if [ -z "$SSL_TYPE" ];then
    SSL_TYPE='n'
fi

if [ -z "$SERVER_NAME" ];then
    echo "未设置服务器域名"
    exit 1
fi

if [ -z "$SITE_NAME" ];then
    echo "未设置配置文件名"
    exit 1
fi

if [ -z "$SITE_ROOT" ];then
    SITE_ROOT="/var/www/${SITE_NAME}"
    echo "未设置根目录,使用默认根目录(${SITE_ROOT})"
fi

if [ -n "${CLIENT_CERT}" ]; then
    if [ ! -f $CLIENT_CERT ];then
        echo "指定客户端证书不存在"
        exit 1
    fi
fi


# 新建配置文件
cat > ${NGINX_CONF}${SITE_NAME} << HERE
server {
	listen 80;
	listen [::]:80;

	# SSL configuration
	#
	#listen 443 ssl;
	#listen [::]:443 ssl;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	include my/${SITE_NAME}/*.conf;

	root ${SITE_ROOT};

	# Add index.php to the list if you are using PHP
	index index.php index.html index.htm index.nginx-debian.html;

	server_name ${SERVER_NAME};

	client_max_body_size 20m;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		#try_files \$uri \$uri/ =404;
        try_files \$uri \$uri/ /index.php\$is_args\$args;
	}

	# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
	#
	location ~ \.php\$ {
		include snippets/fastcgi-php.conf;
	
		# With php7.0-cgi alone:
		#fastcgi_pass 127.0.0.1:9000;
		# With php7.0-fpm:
		fastcgi_pass unix:/run/php/php7.0-fpm.sock;
	}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	location ~ /\.ht {
		deny all;
	}
	
	# for wordpress
	location = /favicon.ico { log_not_found off; access_log off; }
	location = /robots.txt { log_not_found off; access_log off; allow all; }
	location ~* \.(css|gif|ico|jpeg|jpg|js|png)\$ {
		expires max;
		log_not_found off;
	}
}

include my/${SITE_NAME}/*.ser;

HERE

# 新建MY配置文件夹
mkdir -p ${MY_CONF}${SITE_NAME}

# 新建网站根文件夹
mkdir -p ${SITE_ROOT}



######################
## 启用SSL服务器验证 ##
######################


## 使用acme.sh证书 ##

if [ "${SSL_TYPE}" = "y" ]; then

#安装 acme.sh 以自动获取SSL证书
ACME="${HOME}/.acme.sh/acme.sh"
if [ ! -x ${ACME} ]; then
    su - $SUDO_USER -c "curl  https://get.acme.sh | sh" && source "${HOME}/.acme.sh/acme.sh.env"
fi

# 获取SSL证书
${ACME} --issue  -d  ${SERVER_NAME}  --nginx

# 安装SSL证书
mkdir -p ${SSL_PATH}
${ACME}  --installcert  -d  ${SERVER_NAME} \
        --key-file  ${SSL_PATH}${SERVER_NAME}.key \
        --fullchain-file  ${SSL_PATH}${SERVER_NAME}.crt \
        --reloadcmd  "service nginx force-reload" || echo -e "\n\033[31m使用acme.sh安装SSL证书时出现错误!\033[0m" && FAIL_SSL='y'

fi


## 使用自签名证书 ##

if [ "${SSL_TYPE}" = "s" ]; then

#安装 myca.sh 以自动获取SSL证书
MYCA="${HOME}/.ca/myca.sh"
Password=$1
if [ "$Password" = "" ];then
	Password="12345"
fi
if [ ! -x ${MYCA} ]; then
    wget -O install.sh https://raw.githubusercontent.com/kaixinguo360/MyCA/master/install.sh \
                && chmod +x install.sh \
		&& sudo ./install.sh ${Password}
fi

# 获取SSL证书
${MYCA} issue -n ${SERVER_NAME}

# 安装SSL证书
mkdir -p ${SSL_PATH}
${MYCA} export --name  ${SERVER_NAME} \
        --key  ${SSL_PATH}${SERVER_NAME}.key \
        --crt  ${SSL_PATH}${SERVER_NAME}.crt || echo -e "\n\033[31m使用myca.sh安装SSL证书时出现错误!\033[0m" && FAIL_SSL='y'

fi


## 设置Nginx以启用安装的证书 ##

if [[ ! "${SSL_TYPE}" = "n" && -z "${FAIL_SSL}" ]]; then
cat > ${MY_CONF}${SITE_NAME}/ssl.conf << HERE
listen 443 ssl;
listen [::]:443 ssl;
ssl_certificate ${SSL_PATH}${SERVER_NAME}.crt;
ssl_certificate_key ${SSL_PATH}${SERVER_NAME}.key;
keepalive_timeout   70;
HERE
fi


######################
## 启用SSL客户端验证 ##
######################

if [ -n "$CLIENT_CERT" ];then
cat > ${MY_CONF}${SITE_NAME}/ssl_client.conf << HERE
ssl_client_certificate ${CLIENT_CERT};
ssl_verify_client on;
HERE
fi


###############
## 重启Nginx ##
###############
if [ ! "$NO_RESTART" = 'y' ];then
    service nginx restart
fi

